+++
title = 'Paper Reading: SEED Domain-Specific Data Curation With Large Language Models'
date = 2024-03-01T10:42:53-05:00
draft = false
tags = ['Paper Reading']
+++

## SEED: Domain-Specific Data Curation With Large Language Models

使用大型语言模型的 领域特定 数据管理

## ABSTRACT

准备分析数据的数据管理任务 Data Curation 对于将数据转换为可行的见解至关重要。但是，由于不同域中的应用程序的不同要求，通用的现成工具通常不足。结果，数据科学家通常必须开发针对数据集和任务量身定制的特定领域 domain-specific 解决方案，例如在足够数量的带注释的示例上编写特定于域的代码或培训机器学习模型。众所周知，这个过程很困难且耗时。我们提出了 SEED ，这是一种 LLM-as-compiler 方法，该方法自动通过大语言模型（LLMS）自动生成特定于域的数据策划解决方案。用户描述了一个任务，输入数据和预期的量后，SEED compiler 编译器就会生产由 LLM 生成的代码，小型模型和数据访问模块组成的可执行管道。SEED 使用这些生成的模块来处理大部分数据记录，并动态决定 LLM 何时应该介入直接处理一些单独的记录，可能使用数据访问模块从数据源检索相关信息，以协助 LLM 解决任务。为了验证这种新的、革命性的方法，我们在跨越 5 个数据管理任务的 9 个数据集上进行了实验。结果表明，SEED 生成的特定领域的解决方案显著优于它们的通用对应方案，通常接近使用数千个标记训练示例的手动管理解决方案的性能。此外，与在每个数据记录上使用 LLM 的解决方案相比，SEED 实现了最先进的或相当少的性能，**同时显着减少了 LLM 调用的数量**

## INTRODUCTION

数据管理任务是 discover, extract, transform, clean, and integrate data，对各种各样的组织都至关重要。尽管数据管理界做出了巨大的努力，但许多来源仍然报告称，数据科学家仍然将 80% 以上的时间花在这些任务上。这样做的一个关键原因是，不同领域的应用程序有不同的需求，即使是针对单一的数据管理任务，也没有一个通用的解决方案。例如，对于数据提取任务，可以通过**正则表达式**有效地提取货币金额，例如搜索后面跟着以逗号和句号分隔的数字的美元符号，即`$\d[\d|，|`。而提取人名则需要一种完全不同的方法，比如在 Mr.或 Ms.等称呼附近搜索大写的单词。由于这样的案例，通用现成的工具很少足够。取而代之的是，数据科学家通常必须开发针对数据集和问题域量身定制的特定应用解决方案，例如特定领域的特定解决方案代码（如上面的正则表达式）或在大量带注释的示例中训练以执行这些类型的任务的**机器学习模型**。结果，为特定方案设计数据策展解决方案是耗时的，需要进行多轮需求生成，培训数据收集，模型/算法开发以及与数据科学家和域专家进行测试，并且很少可以从一个部署中重复使用到下一个。对于企业而言，这可能是非常昂贵的,例如，Citadel 雇用 50 多名数据管理专家来向其分析师提供高质量的清洁数据,每年使他们花费数千万。

### Our Approach: SEED

在这项工作中，我们提出了 SEED，一种 LLM-as-compiler 的方法，它给出任务的用户描述、输入数据和预期输出(作为 JSON 规范)，自动将该规范编译成专门针对手头数据和应用程序定制的特定领域数据管理解决方案。

关键见解是，LLM 具有令人印象深刻的生成代码能力，执行推理，理解数据的语义和编码常识的能力，将导致数据策划研究的范式转移，并可以在该数据策划方面构建数据策划解决方案 on the fly。实际上，先前的工作表明，LLM 可以在解决特定数据策展任务方面非常有效。与这些先前的工作不同，这些工作直接依赖于 LLM 来处理数据策展任务中的每个记录，SEED 旨在使用 **LLMS 来生成不同数据策划任务的域特异性模块**，其中一些可能涉及 LLMS 的直接调用和一些其中是 LLM 生成的，但一旦生产了 LLM。

> LLM 真的能推理吗？

关键的见解是，LLMs 具有令人印象深刻的生成代码、执行推理、理解数据语义和编码常识的能力，这将导致数据整理研究范式的转变，并使即时构建数据整理解决方案成为可能。事实上，先前的工作已经表明，LLM 在解决特定数据整理任务方面非常有效。与这些直接依赖 LLM 处理数据整理任务中每条记录的前期工作不同，SEED 的目标是利用 LLM 为不同的数据整理任务生成特定领域的模块，其中有些模块可能需要直接调用 LLM，有些模块由 LLM 生成，但生成后并不使用 LLM。

> Simran Arora et al. 2023. Language Models Enable Simple Systems for Generating Structured Views of Heterogeneous Data Lakes. Proc. VLDB Endow. 17, 2 (2023), 92–105
>
> 看上去这非常依赖 LLM 的性能

具体来说，SEED 编译器会生成一个执行管道 由代码、小型模型和数据访问模块以及 和数据访问模块组成的执行流水线。记录的直接调用。在这个执行流水线中，模块以各种方式使用 LLM。方式使用 LLM。例如，代码或小型模型模块由 例如，由 LLM 合成代码或小型模型模块，以提供特定领域的解决方案（如用于提取货币金额的正则表达式）。表达式）。如果这些模块 如果这些模块对某些记录的结果没有信心，SEED 将把它们转发给 LLM 模块，由 LLM 模块对这些结果进行分析。该模块虽然成本高昂，但通常能 该模块虽然价格昂贵，但通常能够对数据项执行复杂的、类似于人类推理的任务。对于 对于每个请求，LLM 模块可能会进一步使用一个数据访问模块，该模块会从一个数据库中检索相关信息。模块，从数据库或其他用户提供的数据中检索相关信息 用户提供的数据中检索相关信息，以协助 LLM 完成任务。在此，SEED 利用 LLM 的推理能力来逐个确定 哪些额外信息和工具将有助于 解决特定任务

这样，SEED 就能利用 LLM 的合成 synthesis、推理 reasoning 和语义理解能力以及编码的常识来构建特定领域的解决方案。理想情况下，用户无需手动编码模块或注释大量训练示例。此外，与之前将 LLM 用于数据整理任务的工作不同，SEED 不需要在每条数据记录上都调用昂贵的 LLM，因为在处理大型数据集时，LLM 会面临可扩展性、效率和成本问题。SEED 分两步进行流水线编译。首先，由于不同的模块可能适合不同的应用，SEED 会解析用户提供的配置文件，生成一个数据整理计划，指定要启用的模块。正如第 2 章中进一步讨论的那样，对于不同的应用，SEED 会根据任务、应用的具体要求和数据的属性，生成不同的计划，这些计划会使用不同的模块组合。接下来，在给定数据整理计划的情况下，SEED 使用 LLM 构建相应的模块，如代码、小型模型或数据访问模块，并将这些生成的模块组装成可执行流水线，逐一处理数据记录。第 3、4 和 5 节将讨论这些模块的细节。

SEED 分两步进行流水线编译。首先，由于不同的模块可能适合不同的应用，SEED 会解析用户提供的配置文件，生成一个数据整理计划，指定要启用的模块。正如第 2 章中进一步讨论的那样，对于不同的应用，SEED 会根据任务、应用的具体要求和数据的属性，生成不同的计划，这些计划会使用不同的模块组合。
接下来，在给定数据整理计划的情况下，SEED 使用 LLM 构建相应的模块，如代码、小型模型或数据访问模块，并将这些生成的模块组装成可执行流水线，逐一处理数据记录。第 3、4 和 5 节将讨论这些模块的细节。

### Contributions

我们的主要贡献在于证明了 LLM 能够以一种全新的、革命性的方法来处理数据整理任务。与传统的数据整理工具不同，SEED 的目标不是提供现成的解决方案供用户应用于自己的数据集。相反，SEED 会根据给定数据集的属性以及用户的特定需求，为给定数据集即时编译实例优化解决方案。在此过程中，用户无需编写任何代码或执行提示工程。
为了验证这一想法，我们构建了 SEED 的初始版本。结果令人鼓舞：通过对构建模块的一些基本优化（我们将在下文介绍），SEED 能够为多个数据整理问题提供高效、有效的解决方案，证明了其在实践中的潜力。特别是，通过在 9 个数据集上的实验，我们发现 SEED 所生成的解决方案大大优于通用解决方案，通常接近于在数千个示例中训练出来的解决方案的性能，这些数据集涵盖了数据估算、数据提取、数据注释、实体解析和数据发现等各种数据整理任务。此外，与在每条数据记录上都使用 LLM 的解决方案相比，SEED 实现了最先进的或可与之媲美的一次性性能，同时大大减少了所需的 LLM 调用次数

我们的技术贡献主要集中在有效生成模块本身，包括

- 代码生成。我们提出了新颖的技术，以**解决 LLM 在生成高质量和稳健代码以及避免人工提示工程和调试方面的局限性**。为了支持具有复杂逻辑的场景，SEED 生成了一系列代码片段，这些代码片段可共同解决任务，因此比单段代码更强大。
- 模型生成。SEED 利用作为 annotators and teachers 的 LLM 生成小型模型。具体来说，我们利用 LLM 提供标签，从而避免了传统学习方法中的人工标注工作。我们设计的算法可以明智地选择要提交给 LLM 的记录，从而最大限度地减少查询 LLM 的频率，同时最大限度地提高所学小型模型的效率。
- 数据访问模块。我们提出了包括批量查询和迭代工具调用在内的优化方案，利用从数据库中提取的相关信息来增强 LLM，从而大大降低执行成本，同时提高准确性。

## SEED OVERVIEW

下面我们将介绍 SEED 的操作。

User Configuration。SEED 通过一个简单的配置文件与用户交互。图 1 显示了实体解析任务的配置。给定一组属性为 "名称"、"制造商 "和 "价格 "的产品，用户需要确定两个产品是否指的是同一件商品。配置主要包括两部分：（1）用自然语言描述任务、输入和输出；（2）（可选）提供可用数据和工具。用户首先指定任务名称、输入和输出。任务名称可以是任意文本。每个输入还包括名称、数据类型和自然语言描述，例如，描述可以包含用户对属性的领域知识。用户以同样的方式定义输出。用户还可以选择提供更多的领域知识。这可以通过自然语言描述、供 SEED 使用的 API 形式的自定义工具或包含示例的数据文件（无论是否加注）来实现。

对于常见的数据整理任务，包括数据提取、数据发现、实体解析、数据估算和数据发现，SEED 提供内置配置模板。这些模板会自动填充配置文件中的所需字段，用户可根据需要对其进行调整。在上述实体解析任务中，模板会在输入字段中填充两个实体，并在输出字段中填充以下信息： "名称：is_same；类型：bool；描述：如果两个标题相同，则为 1： 如果两个标题相同，则为 1，否则为 0"。选择实体解析模板后，用户只需选择性地提供提示和一些示例

Compilation. 用户完成配置后，SEED 会将其编译成符合用户规范的功能 API（例如，在图 1 中的示例中，生成了一个函数 entity_resolution(entity1，entity2) →is_same）。该函数以数据记录对的格式接收数据，并输出一个布尔值，表示其中一对是否匹配。

SEED 分两步编译解决方案： (1) 制定数据整理计划，确定启用哪些模块 (2) 构建模块并将这些模块连接到可执行管道中。

(1) 制定数据管理计划。针对不同的任务和数据集，SEED 使用基于规则的方法来生成不同的计划，并使用不同的模块组合。
作为高级但昂贵的数据分析工具，LLM 模块被默认选择为轻量级代码和小型模型模块的备用模块。一些需要语义理解能力的复杂任务可能会单独使用 LLM 模块，例如，在数据发现中，推理一个表是否与用户的问题相关是 LLM 比简单方法更具优势的领域

代码模块适用于数据整理任务，在这些任务中，大多数情况都可以使用基于规则的方法有效解决，例如数据清理和数据提取。例如，在基于领域知识的数据清理中，用户通常会假定正常数据中存在一些有规律的模式，并将错误识别为违反这些模式的数据记录。正如我们在数据估算任务（第 6.1 节）中的实验所证实的那样，由 LLM 生成的小程序可以有效地实现这一逻辑

Small model modules 小型模型模块适用于可建模为**预测**或生成机器学习任务的数据整理任务。例如，实体解析可视为一个分类问题，它将一对对象分为匹配或不匹配，而数据估算可视为一个生成问题，它根据上下文生成缺失的属性。这些问题可以通过机器学习模型很好地解决，该模型由 LLM 生成的示例或用户提供的示例训练而成

Data access modules 数据访问模块总是与 LLM 模块耦合在一起。它们对于需要大量数据访问的任务特别有用。例如，数据发现需要搜索企业数据，以发现与用户问题最相关的数据。SEED 提供了一套专门用于数据库操作的预定义工具。此外，它还允许使用其他模块（代码或小型模型）作为工具，以及用户提供的其他工具。要在数据访问模块中注册工具，用户只需告知 SEED 工具的 API 并提供简要说明即可。

除了任务之外，在制定数据整理计划时，SEED 还会考虑特定领域的要求或数据的独特属性。例如，如果用户在描述他们的实体解析任务时提出了一些可以用规则轻松表达的特定要求，如产品表中的两条记录如果价格不同就不属于同一项目，那么 SEED 就会生成一个首先使用代码模块而不是小模型的计划。这再次利用了 LLM 的语义理解能力。也就是说，SEED 使用 LLM 来增强基于规则的方法。它读取任务描述，评估基于规则的方法生成的计划，并在必要时对其进行修改

(2) 构建可执行管道。生成数据整理计划后，SEED 会使用 LLM 来帮助构建计划中的模块，并将它们链接到可执行管道中，从而动态协调模块之间的关系。对于使用代码模块的计划，SEED 首先使用预定义模板将配置文件转换为任务描述提示。然后将该提示发送到 LLM，生成一系列自动评估和完善的代码片段（第 3 章）。这样就生成了一个可调用的方法，如实体解决代码（entity_resolution_code()）。同样，对于具有小型模型的计划，SEED 会生成一个提示模板，请求 LLM 对数据进行注释，然后生成一个可调用的方法，例如 entity_resolution_model()，该方法与在 LLM 注释数据上训练的小型模型相对应（第 4 节）。对于启用了数据访问模块的计划，SEED 会生成一个提示，将 LLM 连接到与给定任务相关的数据访问接口，并为 LLM 选择性地使用这些接口提取数据编制一个迭代过程（第 5.2 节）。这也会生成一个可调用的方法，如 entity_resolution_da()。最终，SEED 将这些内部方法调用连接起来，生成一个最终方法，例如，entity_resolution(entity1, entity2) → is_same

请注意，虽然这不是本文的重点，但我们在 SEED 中花费了大量精力，精心设计了动态提示组成模板，这些模板在这些类型的数据整理任务中普遍表现良好，从而消除了用户对提示工程的需求。有关提示模板，请参阅扩展版附录 D [36]。

模块执行。生成的方法根据数据整理计划依次执行模块，逐一处理每条数据记录。**每个模块决定是直接返回结果还是将结果传递给下一个模块**。对于代码模块，当遇到不确定的情况时，生成的代码片段会被明确指示放弃（第 3.1 节），这些代码片段将继续流向下一个模块，而小模型模块在产生置信度较低的预测结果时会放弃（第 4.2 节）。数据访问模块从数据中检索相关信息，并将其传递给 LLM，因为它始终与 LLM 模块耦合。接下来，我们将介绍构建单个代码模块、小型模型模块和数据访问模块的技术。

## CODE GENERATION

尽管使用 LLM 生成代码吸引了大量关注，但它也面临着挑战。**LLM 通常难以生成高质量和健壮的代码** 。同时，提示工程和手动验证生成代码的正确性需要投入大量时间，这使得 LLM 生成代码的效率较低。此外，LLM 通常是在小型代码生成任务中进行评估，在生成大型应用或需要复杂逻辑的程序时仍有困难。不过，一些复杂的数据整理任务可能需要实现与多个组合规则相对应的复杂逻辑。例如，从非结构化数据中提取多种类型目标信息的数据提取（如从 HTML 文件中抓取数据记录）很难通过单个代码片段完成

SEED 使用两种技术来应对上述挑战，它们共同提高了生成代码的准确性和稳健性，同时最大限度地减少了人力。首先，**建议代码生成与验证将代码生成和调试作为一个统一的交互过程，充分利用了 LLM 的推理能力**。这一过程是自动的，同时保证了代码的质量。其次，代码集合与演化可以产生一组相互补偿的代码片段。这样，代码组合就能有效处理程序中需要复杂逻辑的情况。我们设计了一种进化方法来迭代优化代码集合。接下来，我们将详细阐述这两种技术。

### Code Generation with Advising and Validation

### ...

> 这篇文章的重点在我看来是他们的 Cache 设计，结合 Local LM 显著降低对 LLM/GPT-4 的调用，同时保证了精度，但是论文写得有点多而且不容易读，切入的角度是 data curation 任务，没有接触过就暂时不读了。代码生成部分也应该有意思，回头研究下他们的代码。

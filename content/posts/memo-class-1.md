+++
title = '阅读笔记：编程高手必学的内存知识 01'
date = 2024-11-07T21:08:55-05:00
draft = false
tags = ['System', 'Memory']
+++

## 为什么可用内存会远超物理内存？

> 结合一些杂七杂八的文章看看
>
> https://www.cnblogs.com/binlovetech/p/17571929.html

为什么要从操作物理内存转向操作虚拟内存？

1. 保护内存，每个进程使用的内存独立、隔离
2. 多进程，内存管理，运行更多应用
3. 局部性

### 局部性原理

时间局部性：未来可能再次访问

空间局部性：内存位置可能再次访问

每个进程都独享 128T 的**虚拟内存空间**

> 是每个进程吗？为什么是 128T，2^64 所以随意定？内核态呢
>
> 为什么要设计那么大 128T 很多都用不完吧

虚拟内存让每个进程都有独立的、私有的内存空间，而且比可用的物理内存要大得多

> 虚拟内存是只有用的时候才会映射吗，所以可以任意分配？

### 虚拟内存

操作系统管理虚拟内存和物理内存映射，通过页管理

程序 `malloc` 的时候会发生页分配，但不一定发生映射，直到需要读写的时候才会真正分配内存页面

> 为什么是 128T 呢，因为 64 位机器，2^64 是很大的，只用了低 48 位也就是 2^48 = 256T，内核态和用户态各一半
>
> 至于 32 位机器，2^32 就只有 4G 了，内核态 1G，用户态 3G 虚拟地址空间
>
> 而且用户态都是低位到高位，内核从高到低

## 页表

CPU 通过 MMU 内存管理单元映射虚拟内存到物理内存，通过操作系统设置页表

页表是由 PTE 页表项组成的数组，虚拟空间每个地址每个页都有 PTE 对应

PTE 也有一些 metadata，比如页面读写权限，是否存在的有效位、脏位等等

> 页表项大小是多少？4 字节？
>
> 这样页表 1024 个页表项也是 4K 占据一个页？页大小也是 4K？
>
> 这样一个页表项对应 4K 页，一个页表就支持 4M

页目录表由 Page Directory Entry PDE 组成，每个 PDE 对应一个页表（开始的物理位置），构成了多级页表结构。

> 多级页表，64 位处理器上有更多级的页表

## CPU - 真实地址

给定虚拟地址，如何映射到物理地址？

1. CPU - 寄存器 (页目录基址寄存器 CR3): 确定页目录地址（最高级页表基地址），在 MMU 找到存储着虚拟地址到物理地址转换页表项

2. PDE 页目录项：32 位虚拟地址拆成 10, 10, 12 位三段，页目录表及地址可以通过计算找到页目录项

3. 页目录项 - 页表 - 页表项：（省略内部计算细节）

4. 虚拟地址 - 物理地址：页表项记录物理地址

对于 64 位机器，使用了 48 位虚拟地址，有 4 级页表

```
+---------------------+
| Page Directory Base |  页目录基地址 (Page Directory Base Address)
+---------------------+
          |
          v
+---------------------+
|   Page Directory    |  页目录表 (Page Directory Table)
+---------------------+
| Page Directory Entry|  页目录项 (Page Directory Entry)
+---------------------+
          |
          v
+---------------------+
|      Page Table     |  页表 (Page Table)
+---------------------+
|    Page Table Entry |  页表项 (Page Table Entry)
+---------------------+
          |
          v
+---------------------+
|   Physical Address  |  物理地址 (Physical Address)
+---------------------+
```

## 页面 SWAP

不经常使用的页面，会被换出内存，存在硬盘 swap 区域，提供给新的虚拟内存

> 页面调度算法如何实现？
>
> FIFO? 还是 RR? 有什么区别?
